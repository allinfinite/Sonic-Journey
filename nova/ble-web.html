<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Lumenate Nova</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }
    h1 { color: #00d4ff; font-size: 24px; margin-bottom: 4px; }
    .subtitle { color: #666; font-size: 13px; margin-bottom: 20px; }
    .buttons { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      padding: 16px 24px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 12px;
      flex: 1;
      min-width: 140px;
    }
    button:active { background: #00a8cc; transform: scale(0.98); }
    button:disabled { background: #444; color: #666; cursor: not-allowed; }
    button, .preset, .pattern-btn { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    button.danger { background: #ff6b6b; }
    button.secondary { background: #6c5ce7; }
    #log {
      background: #0d0d1a;
      padding: 16px;
      border-radius: 12px;
      font-family: ui-monospace, monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 40vh;
      overflow-y: auto;
      margin-top: 20px;
      line-height: 1.4;
    }
    .success { color: #51cf66; }
    .error { color: #ff6b6b; }
    .data { color: #ffd93d; }
    .service { color: #ff6b6b; font-weight: bold; }
    .char { color: #4ecdc4; }
    .info { color: #74c0fc; }
    #battery {
      font-size: 18px;
      margin: 15px 0;
      padding: 12px;
      background: #252547;
      border-radius: 8px;
      display: none;
    }

    /* Effects */
    .section { margin-bottom: 24px; }
    .section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #00d4ff;
      margin-bottom: 10px;
    }
    #presets { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); max-width: 800px; margin: 0 auto; }
    .preset {
      background: #252547;
      border: 2px solid #333;
      border-radius: 12px;
      padding: 20px 16px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
      min-height: 100px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .preset:hover:not(:disabled) { border-color: #00d4ff; background: #2a2a52; transform: translateY(-2px); }
    .preset:active:not(:disabled) { transform: translateY(0); }
    .preset:disabled { opacity: 0.4; cursor: not-allowed; }
    .preset .state-name { font-size: 20px; font-weight: 700; color: #00d4ff; margin-bottom: 6px; }
    .preset .hz { font-size: 14px; color: #888; }
    .preset.active { border-color: #00d4ff; background: #1e3a5f; box-shadow: 0 0 12px rgba(0, 212, 255, 0.3); }
    .preset.active .state-name { color: #00d4ff; }
    
    /* Protocol selector */
    .protocol-selector {
      background: #252547;
      padding: 12px;
      border-radius: 8px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .protocol-selector label { 
      color: #888; 
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
    .protocol-selector input[type="radio"] {
      accent-color: #00d4ff;
    }
    .protocol-info {
      font-size: 11px;
      color: #666;
      margin-left: auto;
    }
    
    /* Debug panel */
    .debug-panel {
      background: #252547;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 16px;
      margin: 20px 0;
      display: none;
    }
    .debug-panel.visible { display: block; }
    .debug-panel h3 {
      color: #00d4ff;
      font-size: 14px;
      margin: 0 0 12px 0;
      font-weight: 600;
    }
    .debug-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .debug-buttons button {
      font-size: 13px;
      padding: 10px 16px;
      min-width: auto;
    }
    .debug-toggle {
      background: #444;
      color: #aaa;
      font-size: 12px;
      padding: 8px 12px;
      margin: 10px 0;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <h1>Lumenate Nova</h1>
  <p class="subtitle">Click a state to start flickering</p>

  <div id="battery"></div>

  <div class="buttons">
    <button id="connectBtn" onclick="connectDevice()">Connect</button>
    <button id="disconnectBtn" onclick="disconnectDevice()" disabled class="danger">Disconnect</button>
  </div>
  
  <div class="protocol-selector">
    <span style="color: #00d4ff; font-weight: 600;">Protocol:</span>
    <label><input type="radio" name="protocol" value="simple" checked> Simple (01ff)</label>
    <label><input type="radio" name="protocol" value="streaming"> Streaming (NEW)</label>
    <span class="protocol-info" id="protocolInfo">Basic on/off flickering</span>
  </div>

  <div class="section" style="margin-top: 24px;">
    <div id="presets"></div>
    <div style="margin-top: 16px; text-align: center;">
      <button onclick="stopFlicker()" class="danger" style="min-width: 200px;">Turn Off</button>
    </div>
  </div>
  
  <button class="debug-toggle" onclick="toggleDebug()">ðŸ”§ Debug Tools</button>
  <div id="debugPanel" class="debug-panel">
    <h3>Streaming Protocol Tests</h3>
    <div class="debug-buttons">
      <button onclick="testCapturedSequence()" class="secondary">Test Captured Bytes</button>
      <button onclick="testHybrid()" class="secondary">Test Hybrid (01ff+Stream)</button>
      <button onclick="testModes()" class="secondary">Test Modes (0-5)</button>
      <button onclick="testStreamingFlash()" class="secondary">Test Streaming Flash</button>
      <button onclick="sendStreamingTest()" class="secondary">Send Single Stream</button>
      <button onclick="startJourneyMode()" class="secondary">Start Journey Mode</button>
    </div>
  </div>

  <div id="log">Tap Connect to start...</div>

  <script>
    // Known Lumenate Nova Service UUIDs
    const CONTROL_SERVICE = '47bbfb1e-670e-4f81-bfb3-78daffc9a783';
    const MCUMGR_SERVICE = 'b568de7c-b6c6-42cb-8303-fcc9cb25007c';
    const BATTERY_SERVICE = '0000180f-0000-1000-8000-00805f9b34fb';

    // Characteristics
    const DATA_CHAR = '2b35ef1f-11a6-4089-8cd5-843c5d0c9c55';
    const COMMAND_CHAR = '3e25a3bf-bfe1-4c71-97c5-5bdb73fac89e';
    const STATUS_CHAR = '964fbffe-6940-4371-8d48-fe43b07ed00b';

    let device = null;
    let server = null;
    let commandChar = null;
    let dataChar = null;
    let flickerInterval = null;
    let journeyMode = false;
    let streamTimestamp = 0;

    // --- Simplified states: click to activate ---
    const STATES = [
      { hz: 3,  name: 'Deep Sleep',   desc: '3 Hz' },
      { hz: 6,  name: 'Meditation',   desc: '6 Hz' },
      { hz: 10, name: 'Visuals',      desc: '10 Hz' },
      { hz: 15, name: 'Focus',        desc: '15 Hz' },
    ];
    let activeState = null;

    function log(msg, className = '') {
      const logEl = document.getElementById('log');
      const line = document.createElement('div');
      line.className = className;
      line.textContent = msg;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }
    
    // Get selected protocol
    function getProtocol() {
      const sel = document.querySelector('input[name="protocol"]:checked');
      return sel ? sel.value : 'simple';
    }
    
    // Update protocol info text
    function updateProtocolInfo() {
      const info = document.getElementById('protocolInfo');
      if (getProtocol() === 'streaming') {
        info.textContent = 'Official app protocol (12-byte streaming)';
      } else {
        info.textContent = 'Basic on/off flickering';
      }
    }
    
    // Listen for protocol changes
    document.querySelectorAll('input[name="protocol"]').forEach(r => {
      r.addEventListener('change', updateProtocolInfo);
    });

    // Build 12-byte streaming command (official protocol)
    function buildStreamingCommand(intensity, mode = 0x0002, timestamp = 0) {
      const cmd = new Uint8Array(12);
      // Little-endian 16-bit values
      cmd[0] = intensity & 0xFF;
      cmd[1] = (intensity >> 8) & 0xFF;
      cmd[2] = mode & 0xFF;
      cmd[3] = (mode >> 8) & 0xFF;
      cmd[4] = timestamp & 0xFF;
      cmd[5] = (timestamp >> 8) & 0xFF;
      // Bytes 6-11 remain zeros
      return cmd;
    }
    
    // Start journey mode (required for streaming protocol)
    async function startJourneyMode() {
      if (!commandChar) return false;
      try {
        // Send 0A to COMMAND_CHAR to start journey mode
        await commandChar.writeValue(new Uint8Array([0x0A]));
        log('Journey mode started (0A)', 'success');
        journeyMode = true;
        streamTimestamp = 0;
        return true;
      } catch (e) {
        log(`Failed to start journey mode: ${e.message}`, 'error');
        return false;
      }
    }

    async function activateState(hz) {
      if (!commandChar) { log('Not connected', 'error'); return; }
      
      // Stop any existing flicker
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      activeState = hz;
      const state = STATES.find(s => s.hz === hz);
      const protocol = getProtocol();
      
      if (protocol === 'streaming' && dataChar) {
        // NEW: Official streaming protocol
        // Start journey mode if not already
        if (!journeyMode) {
          const started = await startJourneyMode();
          if (!started) {
            log('Cannot use streaming - falling back to simple', 'info');
            return activateStateSimple(hz, state);
          }
        }
        
        // Initialize with zeros (reset)
        try {
          await dataChar.writeValue(buildStreamingCommand(0, 0x0002, streamTimestamp));
        } catch (e) {
          log(`Streaming init failed: ${e.message}`, 'error');
          return;
        }
        
        // Stream at ~15 Hz (67ms), calculate intensity based on desired flicker frequency
        const streamRateMs = 67;
        let phase = 0;
        const phaseIncrement = (hz * 2 * Math.PI) / (1000 / streamRateMs);
        
        flickerInterval = setInterval(async () => {
          if (!dataChar) {
            clearInterval(flickerInterval);
            flickerInterval = null;
            return;
          }
          
          // Generate sine wave intensity for smooth flicker
          // Map sine (-1 to 1) to intensity (0 to 65535)
          const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
          phase += phaseIncrement;
          streamTimestamp += streamRateMs;
          
          try {
            await dataChar.writeValue(buildStreamingCommand(intensity, 0x0002, streamTimestamp));
          } catch (e) {
            // Silent fail
          }
        }, streamRateMs);
        
        log(`Streaming: ${state?.name || hz + ' Hz'} (sine wave at ${hz} Hz)`, 'success');
        
      } else {
        // Simple protocol: 01ff repeatedly
        return activateStateSimple(hz, state);
      }
      
      renderPresets();
    }
    
    // Simple protocol implementation
    async function activateStateSimple(hz, state) {
      const intervalMs = Math.round(1000 / hz);
      const trigger = [0x01, 0xFF];
      
      try {
        await commandChar.writeValue(new Uint8Array(trigger));
      } catch (e) {
        log(`Failed to start flicker: ${e.message}`, 'error');
        return;
      }
      
      flickerInterval = setInterval(async () => {
        if (!commandChar) {
          clearInterval(flickerInterval);
          flickerInterval = null;
          return;
        }
        try {
          await commandChar.writeValue(new Uint8Array(trigger));
        } catch (e) {
          // Silent fail
        }
      }, intervalMs);
      
      log(`Activated: ${state?.name || hz + ' Hz'} (flickering at ${hz} Hz, ${intervalMs}ms interval)`, 'success');
      renderPresets();
    }

    async function stopFlicker() {
      if (!commandChar) { log('Not connected', 'error'); return; }
      
      // Stop the flicker interval
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      // For streaming protocol, send zero intensity first
      if (journeyMode && dataChar) {
        try {
          await dataChar.writeValue(buildStreamingCommand(0, 0x0002, streamTimestamp));
          log('Streaming stopped (intensity=0)', 'info');
        } catch (e) {
          // Continue to send 02ff anyway
        }
      }
      
      // Send 02ff to turn off the light
      try {
        await commandChar.writeValue(new Uint8Array([0x02, 0xFF]));
        log('Light turned off (02ff)', 'success');
        activeState = null;
        journeyMode = false;
        renderPresets();
      } catch (e) {
        log(`Failed to turn off: ${e.message}`, 'error');
      }
    }

    function renderPresets() {
      const disabled = !commandChar;
      const html = STATES.map(s => {
        const isActive = activeState === s.hz;
        return `<button class="preset${isActive ? ' active' : ''}" data-hz="${s.hz}" ${disabled ? 'disabled' : ''} type="button">
          <div class="state-name">${s.name}</div>
          <div class="hz">${s.desc}</div>
        </button>`;
      }).join('');
      document.getElementById('presets').innerHTML = html;
      document.getElementById('presets').querySelectorAll('.preset').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.disabled) return;
          const hz = parseInt(btn.dataset.hz, 10);
          activateState(hz);
        });
      });
    }

    async function connectDevice() {
      clearLog();
      log('Scanning for Lumenate Nova...');

      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Lumenate' }],
          optionalServices: [CONTROL_SERVICE, MCUMGR_SERVICE, BATTERY_SERVICE, '180f']
        });

        log('Found: ' + device.name, 'success');
        device.addEventListener('gattserverdisconnected', onDisconnected);

        log('Connecting...');
        server = await device.gatt.connect();
        log('Connected!', 'success');

        document.getElementById('connectBtn').disabled = true;
        document.getElementById('disconnectBtn').disabled = false;

        // Get Battery Level
        try {
          const batteryService = await server.getPrimaryService('battery_service');
          const batteryChar = await batteryService.getCharacteristic('battery_level');
          const batteryValue = await batteryChar.readValue();
          const batteryLevel = batteryValue.getUint8(0);
          document.getElementById('battery').style.display = 'block';
          document.getElementById('battery').textContent = `Battery: ${batteryLevel}%`;
          log(`Battery: ${batteryLevel}%`, 'info');
        } catch (e) {
          log('Battery read skipped', 'info');
        }

        // Discover Control Service
        log('\nDiscovering services...');

        try {
          const controlService = await server.getPrimaryService(CONTROL_SERVICE);
          log('\nControl Service found!', 'service');

          const norm = (u) => (String(u || '').toLowerCase().replace(/-/g, ''));
          let fallbackWrite = null;

          const chars = await controlService.getCharacteristics();
          for (const char of chars) {
            const uuid = char.uuid;
            const props = [];
            if (char.properties.read) props.push('read');
            if (char.properties.write) props.push('write');
            if (char.properties.writeWithoutResponse) props.push('writeNoResp');
            if (char.properties.notify) props.push('notify');

            log(`  ${uuid.slice(0,8)}... (${props.join(', ')})`, 'char');

            // Match command char (UUID can vary in format/casing)
            if (norm(uuid) === norm(COMMAND_CHAR)) {
              commandChar = char;
              log('  ^ Command char ready (for 01ff/02ff)', 'success');
            }
            // DATA_CHAR for streaming protocol
            if (norm(uuid) === norm(DATA_CHAR)) {
              dataChar = char;
              log('  ^ Data char ready (for streaming)', 'success');
            }
            // Fallback: first writable char if COMMAND_CHAR not found
            if (!fallbackWrite && (char.properties.write || char.properties.writeWithoutResponse)) {
              fallbackWrite = char;
            }

            // Subscribe to notifications
            if (char.properties.notify) {
              try {
                await char.startNotifications();
                char.addEventListener('characteristicvaluechanged', (e) => {
                  const bytes = new Uint8Array(e.target.value.buffer);
                  const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
                  log(`[${uuid.slice(0,8)}] ${hex}`, 'data');
                });
                log('  ^ Subscribed', 'success');
              } catch (err) {
                // Silent fail for notify
              }
            }

            // Read initial value
            if (char.properties.read) {
              try {
                const val = await char.readValue();
                const bytes = new Uint8Array(val.buffer);
                const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
                log(`  Value: ${hex}`, 'data');
              } catch (err) {
                // Silent fail for read
              }
            }
          }

          if (!commandChar && fallbackWrite) {
            commandChar = fallbackWrite;
            log('  ^ Using write char as command (COMMAND_CHAR not matched)', 'info');
          }
          
          // Log protocol availability
          if (dataChar) {
            log('Streaming protocol available!', 'info');
          } else {
            log('Streaming protocol unavailable (no DATA_CHAR)', 'info');
          }
          
          // Store globally for testing
          window.dataChar = dataChar;
          window.commandChar = commandChar;
          
          renderPresets();
        } catch (e) {
          log('Control service error: ' + e.message, 'error');
        }

        log('\n--- Ready! Listening for data ---', 'success');

      } catch (err) {
        log('Error: ' + err.message, 'error');
        console.error(err);
      }
    }

    function disconnectDevice() {
      if (device && device.gatt.connected) {
        device.gatt.disconnect();
      }
    }

    function onDisconnected() {
      log('\nDisconnected', 'error');
      document.getElementById('connectBtn').disabled = false;
      document.getElementById('disconnectBtn').disabled = true;
      document.getElementById('battery').style.display = 'none';
      
      // Stop flickering
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      device = null;
      server = null;
      commandChar = null;
      dataChar = null;
      activeState = null;
      journeyMode = false;
      streamTimestamp = 0;
      renderPresets();
    }

    // Expose for console use
    window.sendCommand = async (hexString) => {
      if (!commandChar) {
        log('Not connected', 'error');
        return;
      }
      const bytes = hexString.match(/.{1,2}/g).map(b => parseInt(b, 16));
      await commandChar.writeValue(new Uint8Array(bytes));
      log('Sent: ' + hexString, 'success');
    };
    
    // Console helpers for testing
    window.tryDataChar = async (hexString) => {
      if (!dataChar) {
        log('Data char not available', 'error');
        return;
      }
      const bytes = hexString.match(/.{1,2}/g).map(b => parseInt(b, 16));
      await dataChar.writeValue(new Uint8Array(bytes));
      log(`Sent to DATA_CHAR: ${hexString}`, 'success');
    };
    
    // Test: send just 01ff
    window.testTrigger = async () => {
      if (!commandChar) { log('Not connected', 'error'); return; }
      await commandChar.writeValue(new Uint8Array([0x01, 0xFF]));
      log('Sent 01ff', 'info');
    };
    
    // Toggle debug panel
    function toggleDebug() {
      const panel = document.getElementById('debugPanel');
      panel.classList.toggle('visible');
    }
    
    // Test: start journey mode (0A command)
    window.startJourneyMode = async () => {
      if (!commandChar) { log('Not connected', 'error'); return; }
      await commandChar.writeValue(new Uint8Array([0x0A]));
      journeyMode = true;
      log('Sent 0A (journey mode)', 'success');
    };
    
    // Also expose as window.startJourney for console
    window.startJourney = window.startJourneyMode;
    
    // Test: send streaming command
    window.sendStreaming = async (intensity = 32768, mode = 2, ts = 0) => {
      if (!dataChar) { log('Data char not available', 'error'); return; }
      const cmd = buildStreamingCommand(intensity, mode, ts);
      await dataChar.writeValue(cmd);
      const hex = Array.from(cmd).map(b => b.toString(16).padStart(2, '0')).join('');
      log(`Streaming: intensity=${intensity}, mode=${mode}, ts=${ts} â†’ ${hex}`, 'success');
    };
    
    // Test: flash with streaming protocol
    window.testStreamingFlash = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      const hz = 10;
      const duration = 5000;
      
      // Start journey mode
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Journey mode started', 'info');
      journeyMode = true;
      
      // Stream for duration
      const streamRateMs = 67;
      let phase = 0;
      const phaseIncrement = (hz * 2 * Math.PI) / (1000 / streamRateMs);
      let ts = 0;
      
      const interval = setInterval(async () => {
        const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
        phase += phaseIncrement;
        ts += streamRateMs;
        
        try {
          await dataChar.writeValue(buildStreamingCommand(intensity, 0x0002, ts));
        } catch (e) {}
      }, streamRateMs);
      
      log(`Streaming test at ${hz} Hz for ${duration}ms...`, 'info');
      
      setTimeout(async () => {
        clearInterval(interval);
        await dataChar.writeValue(buildStreamingCommand(0, 0x0002, ts));
        await commandChar.writeValue(new Uint8Array([0x02, 0xFF]));
        log('Streaming test complete', 'success');
      }, duration);
    };
    
    // Test: send single streaming command
    window.sendStreamingTest = async () => {
      if (!dataChar) { log('Data char not available', 'error'); return; }
      if (!journeyMode) {
        log('Starting journey mode first...', 'info');
        await startJourneyMode();
        await new Promise(r => setTimeout(r, 200));
      }
      const cmd = buildStreamingCommand(32768, 0x0002, 0);
      await dataChar.writeValue(cmd);
      const hex = Array.from(cmd).map(b => b.toString(16).padStart(2, '0')).join(' ');
      log(`Sent: ${hex}`, 'success');
    };
    
    // Test: send EXACT captured bytes from official app
    window.testCapturedSequence = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      log('Testing exact captured sequence...', 'info');
      
      // 1. Send 0A to start journey mode (handle 0x0039)
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Sent 0A to COMMAND_CHAR', 'success');
      
      // Wait a moment for device to respond
      await new Promise(r => setTimeout(r, 200));
      
      // 2. Send initial zero command
      const zero = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      await dataChar.writeValue(zero);
      log('Sent zeros to DATA_CHAR', 'info');
      
      // 3. Send first captured command: 0032 0200 CF31 0000 0000 0000
      // In bytes: 00 32 02 00 CF 31 00 00 00 00 00 00
      const cmd1 = new Uint8Array([0x00, 0x32, 0x02, 0x00, 0xCF, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      await dataChar.writeValue(cmd1);
      log('Sent captured cmd1: 00320200cf31...', 'success');
      
      await new Promise(r => setTimeout(r, 150));
      
      // 4. Send more captured commands
      const cmd2 = new Uint8Array([0xD1, 0x2A, 0x02, 0x00, 0x73, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      await dataChar.writeValue(cmd2);
      log('Sent captured cmd2: d12a02007335...', 'success');
      
      await new Promise(r => setTimeout(r, 150));
      
      const cmd3 = new Uint8Array([0x52, 0x24, 0x02, 0x00, 0xBF, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      await dataChar.writeValue(cmd3);
      log('Sent captured cmd3: 52240200bf38...', 'success');
      
      log('Captured sequence sent - any light?', 'info');
    };
    
    // Test: maybe streaming controls something else - try 01ff + streaming together
    window.testHybrid = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      log('Testing hybrid: 01ff + streaming...', 'info');
      
      // Start journey mode
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Journey mode started', 'info');
      journeyMode = true;
      
      await new Promise(r => setTimeout(r, 100));
      
      // Turn on light with 01ff
      await commandChar.writeValue(new Uint8Array([0x01, 0xFF]));
      log('Light on (01ff)', 'success');
      
      // Now stream intensity values
      let ts = 0;
      const streamRateMs = 100;
      let count = 0;
      
      const interval = setInterval(async () => {
        // Oscillate between high and low intensity
        const intensity = (count % 2 === 0) ? 65535 : 0;
        count++;
        ts += streamRateMs;
        
        try {
          await dataChar.writeValue(buildStreamingCommand(intensity, 0x0002, ts));
          log(`Stream: intensity=${intensity}`, 'data');
        } catch (e) {}
        
        if (count > 20) {
          clearInterval(interval);
          log('Hybrid test complete', 'success');
        }
      }, streamRateMs);
    };
    
    // Test: try different mode values
    window.testModes = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Journey mode started', 'info');
      await new Promise(r => setTimeout(r, 100));
      
      // Try different mode values
      for (let mode = 0; mode <= 5; mode++) {
        const cmd = buildStreamingCommand(32768, mode, 0);
        await dataChar.writeValue(cmd);
        log(`Mode ${mode}: intensity=32768`, 'info');
        await new Promise(r => setTimeout(r, 500));
      }
      log('Mode test complete', 'success');
    };

    renderPresets();
  </script>
</body>
</html>
