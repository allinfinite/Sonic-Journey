<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Lumenate Nova</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }
    h1 { color: #00d4ff; font-size: 24px; margin-bottom: 4px; }
    .subtitle { color: #666; font-size: 13px; margin-bottom: 20px; }
    .buttons { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      padding: 16px 24px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 12px;
      flex: 1;
      min-width: 140px;
    }
    button:active { background: #00a8cc; transform: scale(0.98); }
    button:disabled { background: #444; color: #666; cursor: not-allowed; }
    button, .preset, .pattern-btn { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    button.danger { background: #ff6b6b; }
    button.secondary { background: #6c5ce7; }
    #log {
      background: #0d0d1a;
      padding: 16px;
      border-radius: 12px;
      font-family: ui-monospace, monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 40vh;
      overflow-y: auto;
      margin-top: 20px;
      line-height: 1.4;
    }
    .success { color: #51cf66; }
    .error { color: #ff6b6b; }
    .data { color: #ffd93d; }
    .service { color: #ff6b6b; font-weight: bold; }
    .char { color: #4ecdc4; }
    .info { color: #74c0fc; }
    #battery {
      font-size: 18px;
      margin: 15px 0;
      padding: 12px;
      background: #252547;
      border-radius: 8px;
      display: none;
    }

    /* Effects */
    .section { margin-bottom: 24px; }
    .section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #00d4ff;
      margin-bottom: 10px;
    }
    #presets { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); max-width: 800px; margin: 0 auto; }
    .preset {
      background: #252547;
      border: 2px solid #333;
      border-radius: 12px;
      padding: 20px 16px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
      min-height: 100px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .preset:hover:not(:disabled) { border-color: #00d4ff; background: #2a2a52; transform: translateY(-2px); }
    .preset:active:not(:disabled) { transform: translateY(0); }
    .preset:disabled { opacity: 0.4; cursor: not-allowed; }
    .preset .state-name { font-size: 20px; font-weight: 700; color: #00d4ff; margin-bottom: 6px; }
    .preset .hz { font-size: 14px; color: #888; }
    .preset.active { border-color: #00d4ff; background: #1e3a5f; box-shadow: 0 0 12px rgba(0, 212, 255, 0.3); }
    .preset.active .state-name { color: #00d4ff; }
    
    /* Protocol selector */
    .protocol-selector {
      background: #252547;
      padding: 12px;
      border-radius: 8px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .protocol-selector label { 
      color: #888; 
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
    .protocol-selector input[type="radio"] {
      accent-color: #00d4ff;
    }
    .protocol-info {
      font-size: 11px;
      color: #666;
      margin-left: auto;
    }
    
    /* Debug panel */
    .debug-panel {
      background: #252547;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 16px;
      margin: 20px 0;
      display: none;
    }
    .debug-panel.visible { display: block; }
    .debug-panel h3 {
      color: #00d4ff;
      font-size: 14px;
      margin: 0 0 12px 0;
      font-weight: 600;
    }
    .debug-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .debug-buttons button {
      font-size: 13px;
      padding: 10px 16px;
      min-width: auto;
    }
    .debug-toggle {
      background: #444;
      color: #aaa;
      font-size: 12px;
      padding: 8px 12px;
      margin: 10px 0;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <h1>Lumenate Nova</h1>
  <p class="subtitle">Click a state to start flickering</p>

  <div id="battery"></div>

  <div class="buttons">
    <button id="connectBtn" onclick="connectDevice()">Connect</button>
    <button id="disconnectBtn" onclick="disconnectDevice()" disabled class="danger">Disconnect</button>
  </div>
  
  <div class="protocol-selector">
    <span style="color: #00d4ff; font-weight: 600;">Protocol:</span>
    <label><input type="radio" name="protocol" value="simple" checked> Simple (01ff) ‚úì</label>
    <label><input type="radio" name="protocol" value="streaming" disabled> Streaming (Not Working)</label>
    <span class="protocol-info" id="protocolInfo">Basic on/off flickering - Only working method</span>
  </div>

  <div class="section" style="margin-top: 24px;">
    <div id="presets"></div>
    <div style="margin-top: 16px; text-align: center;">
      <button onclick="stopFlicker()" class="danger" style="min-width: 200px;">Turn Off</button>
    </div>
  </div>
  
  <button class="debug-toggle" onclick="toggleDebug()">üîß Debug Tools</button>
  <div id="debugPanel" class="debug-panel">
    <h3>Streaming Protocol Tests</h3>
    <p style="font-size: 12px; color: #888; margin-bottom: 10px;">
      ‚ö†Ô∏è Key fix: Now using writeWithoutResponse (Write Command) to match official app
    </p>
    <div class="debug-buttons">
      <button onclick="testSimpleStreaming()" class="secondary" style="background: #00d4ff; font-weight: 700;">‚ö° Simple Streaming Test</button>
      <button onclick="testWaitForStatus()" class="secondary" style="background: #51cf66;">‚è≥ Wait For Status</button>
      <button onclick="test01ffThenStreaming()" class="secondary" style="background: #ff6b6b;">üî¥ 01ff Then Streaming</button>
      <button onclick="testFullStreaming()" class="secondary" style="background: #00d4ff;">üöÄ Full Streaming Test</button>
      <button onclick="fullInitSequence()" class="secondary" style="background: #6c5ce7; font-weight: 700;">üî¨ Full Init Sequence</button>
      <button onclick="quickInitTest()" class="secondary" style="background: #6c5ce7;">‚ö° Quick Init Test</button>
      <button onclick="testCapturedSequence()" class="secondary">Test Captured Bytes</button>
      <button onclick="testHybrid()" class="secondary">Test Hybrid (01ff+Stream)</button>
      <button onclick="testModes()" class="secondary">Test Modes (0-5)</button>
      <button onclick="testStreamingFlash()" class="secondary">Test Streaming Flash</button>
      <button onclick="sendStreamingTest()" class="secondary">Send Single Stream</button>
      <button onclick="startJourneyMode()" class="secondary">Start Journey Mode</button>
    </div>
  </div>

  <div id="log">Tap Connect to start...</div>

  <script>
    // Known Lumenate Nova Service UUIDs
    const CONTROL_SERVICE = '47bbfb1e-670e-4f81-bfb3-78daffc9a783';
    const MCUMGR_SERVICE = 'b568de7c-b6c6-42cb-8303-fcc9cb25007c';
    const BATTERY_SERVICE = '0000180f-0000-1000-8000-00805f9b34fb';

    // Characteristics
    const DATA_CHAR = '2b35ef1f-11a6-4089-8cd5-843c5d0c9c55';
    const COMMAND_CHAR = '3e25a3bf-bfe1-4c71-97c5-5bdb73fac89e';
    const STATUS_CHAR = '964fbffe-6940-4371-8d48-fe43b07ed00b';

    let device = null;
    let server = null;
    let commandChar = null;
    let dataChar = null;
    let flickerInterval = null;
    let journeyMode = false;
    let streamTimestamp = 0;

    // --- Simplified states: click to activate ---
    const STATES = [
      { hz: 3,  name: 'Deep Sleep',   desc: '3 Hz' },
      { hz: 6,  name: 'Meditation',   desc: '6 Hz' },
      { hz: 10, name: 'Visuals',      desc: '10 Hz' },
      { hz: 15, name: 'Focus',        desc: '15 Hz' },
    ];
    let activeState = null;

    function log(msg, className = '') {
      const logEl = document.getElementById('log');
      const line = document.createElement('div');
      line.className = className;
      line.textContent = msg;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }
    
    // Get selected protocol
    function getProtocol() {
      const sel = document.querySelector('input[name="protocol"]:checked');
      return sel ? sel.value : 'simple';
    }
    
    // Update protocol info text
    function updateProtocolInfo() {
      const info = document.getElementById('protocolInfo');
      if (getProtocol() === 'streaming') {
        info.textContent = '‚ö†Ô∏è Does not work - streaming protocol not functional on this device';
      } else {
        info.textContent = 'Basic on/off flickering - Only working method';
      }
    }
    
    // Listen for protocol changes
    document.querySelectorAll('input[name="protocol"]').forEach(r => {
      r.addEventListener('change', updateProtocolInfo);
    });

    // Build 12-byte streaming command (official protocol)
    function buildStreamingCommand(intensity, mode = 0x0002, timestamp = 0) {
      const cmd = new Uint8Array(12);
      // Little-endian 16-bit values
      cmd[0] = intensity & 0xFF;
      cmd[1] = (intensity >> 8) & 0xFF;
      cmd[2] = mode & 0xFF;
      cmd[3] = (mode >> 8) & 0xFF;
      cmd[4] = timestamp & 0xFF;
      cmd[5] = (timestamp >> 8) & 0xFF;
      // Bytes 6-11 remain zeros
      return cmd;
    }
    
    // Start journey mode (required for streaming protocol)
    async function startJourneyMode() {
      if (!commandChar) return false;
      try {
        // Send 0A to COMMAND_CHAR to start journey mode
        await commandChar.writeValue(new Uint8Array([0x0A]));
        log('Journey mode started (0A)', 'success');
        journeyMode = true;
        streamTimestamp = 0;
        return true;
      } catch (e) {
        log(`Failed to start journey mode: ${e.message}`, 'error');
        return false;
      }
    }

    async function activateState(hz) {
      if (!commandChar) { log('Not connected', 'error'); return; }
      
      // Stop any existing flicker
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      activeState = hz;
      const state = STATES.find(s => s.hz === hz);
      
      // NOTE: Streaming protocol does not work on this device
      // Only the simple 01ff protocol produces lights
      // Always use simple protocol
      return activateStateSimple(hz, state);
    }
    
    // Simple protocol implementation
    async function activateStateSimple(hz, state) {
      const intervalMs = Math.round(1000 / hz);
      const trigger = [0x01, 0xFF];
      
      try {
        await commandChar.writeValue(new Uint8Array(trigger));
      } catch (e) {
        log(`Failed to start flicker: ${e.message}`, 'error');
        return;
      }
      
      flickerInterval = setInterval(async () => {
        if (!commandChar) {
          clearInterval(flickerInterval);
          flickerInterval = null;
          return;
        }
        try {
          await commandChar.writeValue(new Uint8Array(trigger));
        } catch (e) {
          // Silent fail
        }
      }, intervalMs);
      
      log(`Activated: ${state?.name || hz + ' Hz'} (flickering at ${hz} Hz, ${intervalMs}ms interval)`, 'success');
      renderPresets();
    }

    async function stopFlicker() {
      if (!commandChar) { log('Not connected', 'error'); return; }
      
      // Stop the flicker interval
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      // For streaming protocol, send zero intensity first
      if (journeyMode && dataChar) {
        try {
          // Use writeWithoutResponse (Write Command) to match official app
          if (dataChar.properties.writeWithoutResponse) {
            dataChar.writeValueWithoutResponse(buildStreamingCommand(0, 0x0002, streamTimestamp));
          } else {
            await dataChar.writeValue(buildStreamingCommand(0, 0x0002, streamTimestamp));
          }
          log('Streaming stopped (intensity=0)', 'info');
        } catch (e) {
          // Continue to send 02ff anyway
        }
      }
      
      // Send 02ff to turn off the light
      try {
        await commandChar.writeValue(new Uint8Array([0x02, 0xFF]));
        log('Light turned off (02ff)', 'success');
        activeState = null;
        journeyMode = false;
        renderPresets();
      } catch (e) {
        log(`Failed to turn off: ${e.message}`, 'error');
      }
    }

    function renderPresets() {
      const disabled = !commandChar;
      const html = STATES.map(s => {
        const isActive = activeState === s.hz;
        return `<button class="preset${isActive ? ' active' : ''}" data-hz="${s.hz}" ${disabled ? 'disabled' : ''} type="button">
          <div class="state-name">${s.name}</div>
          <div class="hz">${s.desc}</div>
        </button>`;
      }).join('');
      document.getElementById('presets').innerHTML = html;
      document.getElementById('presets').querySelectorAll('.preset').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.disabled) return;
          const hz = parseInt(btn.dataset.hz, 10);
          activateState(hz);
        });
      });
    }

    async function connectDevice() {
      clearLog();
      log('Scanning for Lumenate Nova...');

      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Lumenate' }],
          optionalServices: [
            CONTROL_SERVICE, 
            MCUMGR_SERVICE, 
            BATTERY_SERVICE, 
            '180f', // Battery Service (short UUID)
            '1801', // Generic Attribute Service (for Service Changed)
            '180a'  // Device Information Service (for model, serial, firmware, hardware)
          ]
        });

        log('Found: ' + device.name, 'success');
        device.addEventListener('gattserverdisconnected', onDisconnected);

        log('Connecting...');
        server = await device.gatt.connect();
        log('Connected!', 'success');

        document.getElementById('connectBtn').disabled = true;
        document.getElementById('disconnectBtn').disabled = false;

        // Get Battery Level
        try {
          const batteryService = await server.getPrimaryService('battery_service');
          const batteryChar = await batteryService.getCharacteristic('battery_level');
          const batteryValue = await batteryChar.readValue();
          const batteryLevel = batteryValue.getUint8(0);
          document.getElementById('battery').style.display = 'block';
          document.getElementById('battery').textContent = `Battery: ${batteryLevel}%`;
          log(`Battery: ${batteryLevel}%`, 'info');
        } catch (e) {
          log('Battery read skipped', 'info');
        }

        // Discover Control Service
        log('\nDiscovering services...');

        try {
          controlService = await server.getPrimaryService(CONTROL_SERVICE);
          log('\nControl Service found!', 'service');

          const norm = (u) => (String(u || '').toLowerCase().replace(/-/g, ''));
          let fallbackWrite = null;

          const chars = await controlService.getCharacteristics();
          for (const char of chars) {
            const uuid = char.uuid;
            const props = [];
            if (char.properties.read) props.push('read');
            if (char.properties.write) props.push('write');
            if (char.properties.writeWithoutResponse) props.push('writeNoResp');
            if (char.properties.notify) props.push('notify');

            log(`  ${uuid.slice(0,8)}... (${props.join(', ')})`, 'char');

            // Match command char (UUID can vary in format/casing)
            if (norm(uuid) === norm(COMMAND_CHAR)) {
              commandChar = char;
              log('  ^ Command char ready (for 01ff/02ff)', 'success');
            }
            // DATA_CHAR for streaming protocol
            if (norm(uuid) === norm(DATA_CHAR)) {
              dataChar = char;
              log('  ^ Data char ready (for streaming)', 'success');
            }
            // STATUS_CHAR for device feedback
            if (norm(uuid) === norm(STATUS_CHAR)) {
              statusChar = char;
              log('  ^ Status char ready', 'success');
            }
            // Fallback: first writable char if COMMAND_CHAR not found
            if (!fallbackWrite && (char.properties.write || char.properties.writeWithoutResponse)) {
              fallbackWrite = char;
            }

            // Subscribe to notifications
            if (char.properties.notify) {
              try {
                await char.startNotifications();
                char.addEventListener('characteristicvaluechanged', (e) => {
                  const bytes = new Uint8Array(e.target.value.buffer);
                  const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
                  log(`[${uuid.slice(0,8)}] ${hex}`, 'data');
                });
                log('  ^ Subscribed', 'success');
              } catch (err) {
                // Silent fail for notify
              }
            }

            // Read initial value
            if (char.properties.read) {
              try {
                const val = await char.readValue();
                const bytes = new Uint8Array(val.buffer);
                const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
                log(`  Value: ${hex}`, 'data');
              } catch (err) {
                // Silent fail for read
              }
            }
          }

          if (!commandChar && fallbackWrite) {
            commandChar = fallbackWrite;
            log('  ^ Using write char as command (COMMAND_CHAR not matched)', 'info');
          }
          
          // Log protocol availability
          if (dataChar) {
            log('Streaming protocol available!', 'info');
          } else {
            log('Streaming protocol unavailable (no DATA_CHAR)', 'info');
          }
          
          // Store globally for testing
          window.dataChar = dataChar;
          window.commandChar = commandChar;
          
          renderPresets();
        } catch (e) {
          log('Control service error: ' + e.message, 'error');
        }

        log('\n--- Ready! Listening for data ---', 'success');

      } catch (err) {
        log('Error: ' + err.message, 'error');
        console.error(err);
      }
    }

    function disconnectDevice() {
      if (device && device.gatt.connected) {
        device.gatt.disconnect();
      }
    }

    function onDisconnected() {
      log('\nDisconnected', 'error');
      document.getElementById('connectBtn').disabled = false;
      document.getElementById('disconnectBtn').disabled = true;
      document.getElementById('battery').style.display = 'none';
      
      // Stop flickering
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      device = null;
      server = null;
      commandChar = null;
      dataChar = null;
      activeState = null;
      journeyMode = false;
      streamTimestamp = 0;
      renderPresets();
    }

    // Expose for console use
    window.sendCommand = async (hexString) => {
      if (!commandChar) {
        log('Not connected', 'error');
        return;
      }
      const bytes = hexString.match(/.{1,2}/g).map(b => parseInt(b, 16));
      await commandChar.writeValue(new Uint8Array(bytes));
      log('Sent: ' + hexString, 'success');
    };
    
    // Console helpers for testing
    window.tryDataChar = async (hexString) => {
      if (!dataChar) {
        log('Data char not available', 'error');
        return;
      }
      const bytes = hexString.match(/.{1,2}/g).map(b => parseInt(b, 16));
      const cmd = new Uint8Array(bytes);
      writeStreamingCommand(cmd);
      log(`Sent to DATA_CHAR: ${hexString}`, 'success');
    };
    
    // Test: send just 01ff
    window.testTrigger = async () => {
      if (!commandChar) { log('Not connected', 'error'); return; }
      await commandChar.writeValue(new Uint8Array([0x01, 0xFF]));
      log('Sent 01ff', 'info');
    };
    
    // Toggle debug panel
    function toggleDebug() {
      const panel = document.getElementById('debugPanel');
      panel.classList.toggle('visible');
    }
    
    // Test: start journey mode (0A command)
    window.startJourneyMode = async () => {
      if (!commandChar) { log('Not connected', 'error'); return; }
      await commandChar.writeValue(new Uint8Array([0x0A]));
      journeyMode = true;
      log('Sent 0A (journey mode)', 'success');
    };
    
    // Also expose as window.startJourney for console
    window.startJourney = window.startJourneyMode;
    
    // Helper: write streaming command using correct method (writeWithoutResponse)
    function writeStreamingCommand(cmd, logCmd = false) {
      if (!dataChar) throw new Error('Data char not available');
      // Use writeWithoutResponse (Write Command) to match official app protocol
      if (dataChar.properties.writeWithoutResponse) {
        try {
          dataChar.writeValueWithoutResponse(cmd);
          if (logCmd) {
            const hex = Array.from(cmd).map(b => b.toString(16).padStart(2, '0')).join(' ');
            log(`  ‚úì Sent (writeWithoutResponse): ${hex}`, 'data');
          }
        } catch (e) {
          log(`writeWithoutResponse error: ${e.message}`, 'error');
          throw e;
        }
      } else {
        // Fallback to writeValue if writeWithoutResponse not supported
        log('‚ö†Ô∏è writeWithoutResponse not available, using writeValue', 'info');
        return dataChar.writeValue(cmd);
      }
    }
    
    // Test: send streaming command
    window.sendStreaming = async (intensity = 32768, mode = 2, ts = 0) => {
      if (!dataChar) { log('Data char not available', 'error'); return; }
      const cmd = buildStreamingCommand(intensity, mode, ts);
      writeStreamingCommand(cmd);
      const hex = Array.from(cmd).map(b => b.toString(16).padStart(2, '0')).join('');
      log(`Streaming: intensity=${intensity}, mode=${mode}, ts=${ts} ‚Üí ${hex}`, 'success');
    };
    
    // Test: flash with streaming protocol
    window.testStreamingFlash = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      const hz = 10;
      const duration = 5000;
      
      // Start journey mode
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Journey mode started', 'info');
      journeyMode = true;
      
      // Stream for duration
      const streamRateMs = 67;
      let phase = 0;
      const phaseIncrement = (hz * 2 * Math.PI) / (1000 / streamRateMs);
      let ts = 0;
      
      const interval = setInterval(() => {
        const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
        phase += phaseIncrement;
        ts += streamRateMs;
        
        try {
          writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts));
        } catch (e) {}
      }, streamRateMs);
      
      log(`Streaming test at ${hz} Hz for ${duration}ms...`, 'info');
      
      setTimeout(() => {
        clearInterval(interval);
        writeStreamingCommand(buildStreamingCommand(0, 0x0002, ts));
        commandChar.writeValue(new Uint8Array([0x02, 0xFF]));
        log('Streaming test complete', 'success');
      }, duration);
    };
    
    // Test: send single streaming command
    window.sendStreamingTest = async () => {
      if (!dataChar) { log('Data char not available', 'error'); return; }
      if (!journeyMode) {
        log('Starting journey mode first...', 'info');
        await startJourneyMode();
        await new Promise(r => setTimeout(r, 200));
      }
      const cmd = buildStreamingCommand(32768, 0x0002, 0);
      writeStreamingCommand(cmd);
      const hex = Array.from(cmd).map(b => b.toString(16).padStart(2, '0')).join(' ');
      log(`Sent: ${hex}`, 'success');
    };
    
    // Test: send EXACT captured bytes from official app
    window.testCapturedSequence = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      log('Testing exact captured sequence...', 'info');
      
      // 1. Send 0A to start journey mode (handle 0x0039)
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Sent 0A to COMMAND_CHAR', 'success');
      
      // Wait a moment for device to respond
      await new Promise(r => setTimeout(r, 200));
      
      // 2. Send initial zero command (CRITICAL: must be first after 0A)
      const zero = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      writeStreamingCommand(zero);
      log('Sent zeros to DATA_CHAR', 'info');
      
      await new Promise(r => setTimeout(r, 50));
      
      // 3. Send first captured command: 0032 0200 CF31 0000 0000 0000
      // In bytes: 00 32 02 00 CF 31 00 00 00 00 00 00
      const cmd1 = new Uint8Array([0x00, 0x32, 0x02, 0x00, 0xCF, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      writeStreamingCommand(cmd1);
      log('Sent captured cmd1: 00320200cf31...', 'success');
      
      await new Promise(r => setTimeout(r, 67)); // ~15 Hz = 67ms
      
      // 4. Send more captured commands
      const cmd2 = new Uint8Array([0xD1, 0x2A, 0x02, 0x00, 0x73, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      writeStreamingCommand(cmd2);
      log('Sent captured cmd2: d12a02007335...', 'success');
      
      await new Promise(r => setTimeout(r, 67));
      
      const cmd3 = new Uint8Array([0x52, 0x24, 0x02, 0x00, 0xBF, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
      writeStreamingCommand(cmd3);
      log('Sent captured cmd3: 52240200bf38...', 'success');
      
      log('Captured sequence sent - any light?', 'info');
    };
    
    // Test: maybe streaming controls something else - try 01ff + streaming together
    window.testHybrid = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      log('Testing hybrid: 01ff + streaming...', 'info');
      
      // Start journey mode
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Journey mode started', 'info');
      journeyMode = true;
      
      await new Promise(r => setTimeout(r, 100));
      
      // Turn on light with 01ff
      await commandChar.writeValue(new Uint8Array([0x01, 0xFF]));
      log('Light on (01ff)', 'success');
      
      // Now stream intensity values
      let ts = 0;
      const streamRateMs = 100;
      let count = 0;
      
      const interval = setInterval(() => {
        // Oscillate between high and low intensity
        const intensity = (count % 2 === 0) ? 65535 : 0;
        count++;
        ts += streamRateMs;
        
        try {
          writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts));
          log(`Stream: intensity=${intensity}`, 'data');
        } catch (e) {}
        
        if (count > 20) {
          clearInterval(interval);
          log('Hybrid test complete', 'success');
        }
      }, streamRateMs);
    };
    
    // Test: try different mode values
    window.testModes = async () => {
      if (!commandChar || !dataChar) { log('Not fully connected', 'error'); return; }
      
      await commandChar.writeValue(new Uint8Array([0x0A]));
      log('Journey mode started', 'info');
      await new Promise(r => setTimeout(r, 100));
      
      // Try different mode values
      for (let mode = 0; mode <= 5; mode++) {
        const cmd = buildStreamingCommand(32768, mode, 0);
        writeStreamingCommand(cmd);
        log(`Mode ${mode}: intensity=32768`, 'info');
        await new Promise(r => setTimeout(r, 500));
      }
      log('Mode test complete', 'success');
    };
    
    // COMPREHENSIVE: Full initialization sequence from official app
    window.fullInitSequence = async () => {
      if (!server || !commandChar || !dataChar) { 
        log('Not fully connected', 'error'); 
        return; 
      }
      
      log('=== FULL INITIALIZATION SEQUENCE ===', 'info');
      
      try {
        // Step 1: Request MTU (Web Bluetooth doesn't expose this directly, but we can try)
        // Note: Web Bluetooth handles MTU automatically, but we'll note it
        log('Step 1: MTU negotiation (handled by browser)', 'info');
        
        // Step 2: Enable Service Changed indications
        // This is typically on the Generic Attribute Service (0x1801)
        try {
          const gattService = await server.getPrimaryService('generic_attribute');
          const serviceChangedChar = await gattService.getCharacteristic('service_changed');
          const cccd = await serviceChangedChar.getDescriptor('2902');
          await cccd.writeValue(new Uint8Array([0x02, 0x00]));
          log('Step 2: Service Changed indications enabled', 'success');
        } catch (e) {
          log(`Step 2: Service Changed (may not be available): ${e.message}`, 'info');
        }
        
        // Step 3: Enable Battery notifications
        try {
          const batteryService = await server.getPrimaryService('battery_service');
          const batteryChar = await batteryService.getCharacteristic('battery_level');
          const batteryCccd = await batteryChar.getDescriptor('2902');
          await batteryCccd.writeValue(new Uint8Array([0x01, 0x00]));
          log('Step 3: Battery notifications enabled', 'success');
        } catch (e) {
          log(`Step 3: Battery notifications: ${e.message}`, 'info');
        }
        
        // Step 4: Read Battery Level
        try {
          const batteryService = await server.getPrimaryService('battery_service');
          const batteryChar = await batteryService.getCharacteristic('battery_level');
          const batteryValue = await batteryChar.readValue();
          const batteryLevel = batteryValue.getUint8(0);
          log(`Step 4: Battery Level: ${batteryLevel}%`, 'success');
        } catch (e) {
          log(`Step 4: Battery read: ${e.message}`, 'info');
        }
        
        // Step 5-8: Read Device Info (Model, Serial, Firmware, Hardware)
        // These are on the Device Information Service (0x180A)
        try {
          const deviceInfoService = await server.getPrimaryService('device_information');
          
          // Model Number
          try {
            const modelChar = await deviceInfoService.getCharacteristic('model_number_string');
            const modelValue = await modelChar.readValue();
            const model = new TextDecoder().decode(modelValue);
            log(`Step 5: Model: ${model}`, 'success');
          } catch (e) {
            log(`Step 5: Model read: ${e.message}`, 'info');
          }
          
          // Serial Number
          try {
            const serialChar = await deviceInfoService.getCharacteristic('serial_number_string');
            const serialValue = await serialChar.readValue();
            const serial = new TextDecoder().decode(serialValue);
            log(`Step 6: Serial: ${serial}`, 'success');
          } catch (e) {
            log(`Step 6: Serial read: ${e.message}`, 'info');
          }
          
          // Firmware Version
          try {
            const fwChar = await deviceInfoService.getCharacteristic('firmware_revision_string');
            const fwValue = await fwChar.readValue();
            const fw = new TextDecoder().decode(fwValue);
            log(`Step 7: Firmware: ${fw}`, 'success');
          } catch (e) {
            log(`Step 7: Firmware read: ${e.message}`, 'info');
          }
          
          // Hardware Version
          try {
            const hwChar = await deviceInfoService.getCharacteristic('hardware_revision_string');
            const hwValue = await hwChar.readValue();
            const hw = new TextDecoder().decode(hwValue);
            log(`Step 8: Hardware: ${hw}`, 'success');
          } catch (e) {
            log(`Step 8: Hardware read: ${e.message}`, 'info');
          }
        } catch (e) {
          log(`Steps 5-8: Device Info Service: ${e.message}`, 'info');
        }
        
        // Step 9: Enable DATA_CHAR notifications (0x001B CCCD)
        // This is the CCCD for DATA_CHAR
        try {
          const dataCccd = await dataChar.getDescriptor('2902');
          await dataCccd.writeValue(new Uint8Array([0x01, 0x00]));
          log('Step 9: DATA_CHAR notifications enabled', 'success');
        } catch (e) {
          log(`Step 9: DATA_CHAR CCCD: ${e.message}`, 'info');
        }
        
        // Step 10: Enable STATUS_CHAR notifications (0x002F CCCD)
        if (statusChar) {
          try {
            const statusCccd = await statusChar.getDescriptor('2902');
            await statusCccd.writeValue(new Uint8Array([0x01, 0x00]));
            log('Step 10: STATUS_CHAR notifications enabled', 'success');
          } catch (e) {
            log(`Step 10: STATUS_CHAR CCCD: ${e.message}`, 'info');
          }
        } else {
          log('Step 10: STATUS_CHAR not available', 'info');
        }
        
        // Step 11: START JOURNEY - Send 0A to COMMAND_CHAR
        await commandChar.writeValue(new Uint8Array([0x0A]));
        log('Step 11: Journey mode started (0A)', 'success');
        journeyMode = true;
        await new Promise(r => setTimeout(r, 200));
        
        // Step 12: Enable streaming feedback (0x0037 CCCD)
        // This might be another CCCD for DATA_CHAR or a different characteristic
        try {
          const dataCccd2 = await dataChar.getDescriptor('2902');
          await dataCccd2.writeValue(new Uint8Array([0x01, 0x00]));
          log('Step 12: Streaming feedback enabled', 'success');
        } catch (e) {
          log(`Step 12: Streaming feedback: ${e.message}`, 'info');
        }
        
        // Step 13: Begin streaming - send initial zero command (CRITICAL: must be first)
        writeStreamingCommand(buildStreamingCommand(0, 0x0002, 0));
        log('Step 13: Initial zero command sent', 'success');
        await new Promise(r => setTimeout(r, 50));
        
        // Step 14: Send first captured command
        const cmd1 = new Uint8Array([0x00, 0x32, 0x02, 0x00, 0xCF, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        writeStreamingCommand(cmd1);
        log('Step 14: First captured command sent (00320200cf31...)', 'success');
        
        // Step 15: Stream a few more commands at ~15 Hz (67ms intervals)
        await new Promise(r => setTimeout(r, 67));
        const cmd2 = new Uint8Array([0xD1, 0x2A, 0x02, 0x00, 0x73, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        writeStreamingCommand(cmd2);
        log('Step 15: Second command sent', 'success');
        
        await new Promise(r => setTimeout(r, 67));
        const cmd3 = new Uint8Array([0x52, 0x24, 0x02, 0x00, 0xBF, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        writeStreamingCommand(cmd3);
        log('Step 16: Third command sent', 'success');
        
        log('=== INITIALIZATION COMPLETE ===', 'success');
        log('Check if lights are on!', 'info');
        
      } catch (e) {
        log(`Initialization error: ${e.message}`, 'error');
        console.error(e);
      }
    };
    
    // Store controlService globally for fullInitSequence
    let controlService = null;
    let statusChar = null;
    
    // SIMPLIFIED: Just try the key missing steps
    window.quickInitTest = async () => {
      if (!server || !commandChar || !dataChar) { 
        log('Not fully connected', 'error'); 
        return; 
      }
      
      log('=== QUICK INIT TEST ===', 'info');
      
      try {
        // 1. Read device info (this might "wake up" the device)
        try {
          const deviceInfoService = await server.getPrimaryService('device_information');
          const modelChar = await deviceInfoService.getCharacteristic('model_number_string');
          const model = await modelChar.readValue();
          log(`Device Model: ${new TextDecoder().decode(model)}`, 'success');
        } catch (e) {
          log(`Device info read: ${e.message}`, 'info');
        }
        
        // 2. Enable all notifications we can find
        if (controlService) {
          const chars = await controlService.getCharacteristics();
          for (const char of chars) {
            if (char.properties.notify) {
              try {
                await char.startNotifications();
                log(`Enabled notifications on ${char.uuid.slice(0,8)}...`, 'success');
              } catch (e) {}
            }
          }
        }
        
        // 3. Start journey mode
        await commandChar.writeValue(new Uint8Array([0x0A]));
        log('Journey mode started', 'success');
        journeyMode = true;
        await new Promise(r => setTimeout(r, 300));
        
        // 4. Send initial zero (CRITICAL: must be first after 0A)
        writeStreamingCommand(buildStreamingCommand(0, 0x0002, 0));
        log('Initial zero sent', 'info');
        await new Promise(r => setTimeout(r, 50));
        
        // 5. Send captured sequence
        const cmd1 = new Uint8Array([0x00, 0x32, 0x02, 0x00, 0xCF, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        writeStreamingCommand(cmd1);
        log('Captured cmd1 sent', 'success');
        
        await new Promise(r => setTimeout(r, 67)); // ~15 Hz timing
        
        // 6. Stream a pattern at ~15 Hz
        log('Streaming pattern...', 'info');
        let ts = 0;
        for (let i = 0; i < 10; i++) {
          const intensity = Math.floor((Math.sin(i * 0.5) + 1) / 2 * 65535);
          writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts));
          ts += 67; // Match ~15 Hz timing
          await new Promise(r => setTimeout(r, 67));
        }
        
        log('Quick test complete - any lights?', 'success');
      } catch (e) {
        log(`Quick test error: ${e.message}`, 'error');
        console.error(e);
      }
    };
    
    // SIMPLE DIRECT TEST: Minimal steps to test streaming
    window.testSimpleStreaming = async () => {
      if (!commandChar || !dataChar) { 
        log('Not fully connected', 'error'); 
        return; 
      }
      
      log('=== SIMPLE STREAMING TEST ===', 'info');
      log('Checking dataChar properties...', 'info');
      log(`  writeWithoutResponse: ${dataChar.properties.writeWithoutResponse}`, 'info');
      log(`  write: ${dataChar.properties.write}`, 'info');
      
      try {
        // 1. Start journey mode
        log('Step 1: Sending 0A to start journey mode...', 'info');
        await commandChar.writeValue(new Uint8Array([0x0A]));
        journeyMode = true;
        log('Journey mode started', 'success');
        await new Promise(r => setTimeout(r, 300));
        
        // 2. Send initial zero command
        log('Step 2: Sending initial zero command...', 'info');
        const zeroCmd = buildStreamingCommand(0, 0x0002, 0);
        const zeroHex = Array.from(zeroCmd).map(b => b.toString(16).padStart(2, '0')).join(' ');
        log(`  Command: ${zeroHex}`, 'data');
        writeStreamingCommand(zeroCmd);
        log('Initial zero sent', 'success');
        await new Promise(r => setTimeout(r, 100));
        
        // 3. Send a few test commands with increasing intensity
        log('Step 3: Sending test commands...', 'info');
        for (let i = 0; i < 5; i++) {
          const intensity = Math.floor((i / 4) * 65535); // 0 to 65535
          const ts = i * 67;
          const cmd = buildStreamingCommand(intensity, 0x0002, ts);
          const hex = Array.from(cmd).map(b => b.toString(16).padStart(2, '0')).join(' ');
          log(`  Command ${i+1}: intensity=${intensity}, ts=${ts} ‚Üí ${hex}`, 'data');
          writeStreamingCommand(cmd);
          await new Promise(r => setTimeout(r, 67));
        }
        
        // 4. Try the exact captured command
        log('Step 4: Sending exact captured command...', 'info');
        const capturedCmd = new Uint8Array([0x00, 0x32, 0x02, 0x00, 0xCF, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        const capturedHex = Array.from(capturedCmd).map(b => b.toString(16).padStart(2, '0')).join(' ');
        log(`  Command: ${capturedHex}`, 'data');
        writeStreamingCommand(capturedCmd);
        log('Captured command sent', 'success');
        await new Promise(r => setTimeout(r, 200));
        
        // 5. Stream a pattern for 3 seconds
        log('Step 5: Streaming pattern for 3 seconds...', 'info');
        const streamRateMs = 67;
        const duration = 3000;
        let ts = 0;
        let count = 0;
        const targetHz = 10;
        let phase = 0;
        const phaseIncrement = (targetHz * 2 * Math.PI) / (1000 / streamRateMs);
        
        const interval = setInterval(() => {
          const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
          phase += phaseIncrement;
          ts += streamRateMs;
          count++;
          
          try {
            writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts));
            if (count % 10 === 0) {
              log(`  Sent ${count} commands, intensity=${intensity}`, 'data');
            }
          } catch (e) {
            log(`Stream error: ${e.message}`, 'error');
            clearInterval(interval);
          }
        }, streamRateMs);
        
        setTimeout(() => {
          clearInterval(interval);
          writeStreamingCommand(buildStreamingCommand(0, 0x0002, ts));
          log(`=== TEST COMPLETE (sent ${count} commands) ===`, 'success');
          log('Did you see any lights?', 'info');
        }, duration);
        
      } catch (e) {
        log(`Simple streaming test error: ${e.message}`, 'error');
        console.error(e);
      }
    };
    
    // COMPREHENSIVE TEST: Full init + streaming with correct protocol
    window.testFullStreaming = async () => {
      if (!server || !commandChar || !dataChar) { 
        log('Not fully connected', 'error'); 
        return; 
      }
      
      log('=== FULL STREAMING TEST (with writeWithoutResponse) ===', 'info');
      
      try {
        // 1. Run full initialization sequence
        log('Running full initialization...', 'info');
        await fullInitSequence();
        await new Promise(r => setTimeout(r, 500));
        
        // 2. Verify we're in journey mode
        if (!journeyMode) {
          log('Starting journey mode...', 'info');
          await commandChar.writeValue(new Uint8Array([0x0A]));
          journeyMode = true;
          await new Promise(r => setTimeout(r, 200));
        }
        
        // 3. Send initial zero command (CRITICAL - must be first)
        log('Sending initial zero command...', 'info');
        writeStreamingCommand(buildStreamingCommand(0, 0x0002, 0));
        await new Promise(r => setTimeout(r, 50));
        
        // 4. Stream a 10 Hz flicker pattern for 5 seconds
        log('Streaming 10 Hz flicker pattern...', 'info');
        const streamRateMs = 67; // ~15 Hz update rate
        const duration = 5000;
        let ts = 0;
        const targetHz = 10;
        let phase = 0;
        const phaseIncrement = (targetHz * 2 * Math.PI) / (1000 / streamRateMs);
        
        const interval = setInterval(() => {
          // Generate sine wave for smooth flicker
          const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
          phase += phaseIncrement;
          ts += streamRateMs;
          
          try {
            writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts));
          } catch (e) {
            log(`Stream error: ${e.message}`, 'error');
            clearInterval(interval);
          }
        }, streamRateMs);
        
        setTimeout(() => {
          clearInterval(interval);
          writeStreamingCommand(buildStreamingCommand(0, 0x0002, ts));
          log('=== STREAMING TEST COMPLETE ===', 'success');
          log('Did you see any lights flickering?', 'info');
        }, duration);
        
      } catch (e) {
        log(`Full streaming test error: ${e.message}`, 'error');
        console.error(e);
      }
    };
    
    // Test: Follow exact capture sequence - 0A, then enable DATA_CHAR notifications, then stream
    window.testWaitForStatus = async () => {
      if (!commandChar || !dataChar || !statusChar) { 
        log('Not fully connected (need statusChar)', 'error'); 
        return; 
      }
      
      log('=== TEST: EXACT CAPTURE SEQUENCE ===', 'info');
      log('Following: 0A ‚Üí Enable DATA_CHAR notifications ‚Üí Wait for status ‚Üí Stream', 'info');
      
      // Track status notifications
      let statusReceived = false;
      let statusCount = 0;
      const statusListener = (e) => {
        const bytes = new Uint8Array(e.target.value.buffer);
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
        statusCount++;
        log(`[STATUS ${statusCount}]: ${hex}`, 'data');
        statusReceived = true;
      };
      
      // Listen for status notifications
      try {
        await statusChar.startNotifications();
        statusChar.addEventListener('characteristicvaluechanged', statusListener);
        log('Listening for status notifications...', 'info');
      } catch (e) {
        log(`Failed to start status notifications: ${e.message}`, 'error');
        return;
      }
      
      try {
        // Step 1: Start journey mode (0A to COMMAND_CHAR)
        log('Step 1: Sending 0A to COMMAND_CHAR...', 'info');
        await commandChar.writeValue(new Uint8Array([0x0A]));
        journeyMode = true;
        log('Journey mode started (0A sent)', 'success');
        await new Promise(r => setTimeout(r, 100));
        
        // Step 2: Enable DATA_CHAR notifications (0x0037 = 0100) - THIS IS AFTER 0A in capture!
        log('Step 2: Enabling DATA_CHAR notifications (0x0037 = 0100)...', 'info');
        try {
          const dataCccd = await dataChar.getDescriptor('2902');
          await dataCccd.writeValue(new Uint8Array([0x01, 0x00]));
          log('DATA_CHAR notifications enabled', 'success');
        } catch (e) {
          log(`Failed to enable DATA_CHAR notifications: ${e.message}`, 'error');
        }
        await new Promise(r => setTimeout(r, 100));
        
        // Step 3: Wait for status notifications (device should start sending them)
        log('Step 3: Waiting for status notifications (up to 2 seconds)...', 'info');
        let waited = 0;
        while (!statusReceived && waited < 2000) {
          await new Promise(r => setTimeout(r, 100));
          waited += 100;
          if (waited % 500 === 0) {
            log(`  Still waiting... (${waited}ms)`, 'info');
          }
        }
        
        if (statusReceived) {
          log(`‚úì Received status notification after ${waited}ms`, 'success');
        } else {
          log('‚ö† No status notification received, continuing anyway...', 'info');
        }
        
        await new Promise(r => setTimeout(r, 200));
        
        // Step 4: Send initial zero command (CRITICAL: must be first streaming command)
        log('Step 4: Sending initial zero command...', 'info');
        writeStreamingCommand(buildStreamingCommand(0, 0x0002, 0), true);
        await new Promise(r => setTimeout(r, 50));
        
        // Step 5: Send captured command
        log('Step 5: Sending captured command (00320200cf31)...', 'info');
        const capturedCmd = new Uint8Array([0x00, 0x32, 0x02, 0x00, 0xCF, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        writeStreamingCommand(capturedCmd, true);
        await new Promise(r => setTimeout(r, 67));
        
        // Step 6: Stream pattern
        log('Step 6: Streaming pattern for 5 seconds...', 'info');
        const streamRateMs = 67;
        const duration = 5000;
        let ts = 0;
        let count = 0;
        const targetHz = 10;
        let phase = 0;
        const phaseIncrement = (targetHz * 2 * Math.PI) / (1000 / streamRateMs);
        
        const interval = setInterval(() => {
          const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
          phase += phaseIncrement;
          ts += streamRateMs;
          count++;
          
          try {
            writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts), count % 15 === 0);
          } catch (e) {
            log(`Stream error: ${e.message}`, 'error');
            clearInterval(interval);
          }
        }, streamRateMs);
        
        setTimeout(() => {
          clearInterval(interval);
          statusChar.removeEventListener('characteristicvaluechanged', statusListener);
          writeStreamingCommand(buildStreamingCommand(0, 0x0002, ts));
          log(`=== TEST COMPLETE ===`, 'success');
          log(`Sent ${count} streaming commands, received ${statusCount} status notifications`, 'info');
          log('Did you see any lights?', 'info');
        }, duration);
        
      } catch (e) {
        statusChar.removeEventListener('characteristicvaluechanged', statusListener);
        log(`Test error: ${e.message}`, 'error');
        console.error(e);
      }
    };
    
    // Test: Try 01ff first, then streaming (maybe streaming only works when light is already on?)
    window.test01ffThenStreaming = async () => {
      if (!commandChar || !dataChar) { 
        log('Not fully connected', 'error'); 
        return; 
      }
      
      log('=== TEST: 01ff THEN STREAMING ===', 'info');
      
      try {
        // 1. Turn on light with 01ff (we know this works)
        log('Step 1: Turning on light with 01ff...', 'info');
        await commandChar.writeValue(new Uint8Array([0x01, 0xFF]));
        log('Light should be on now', 'success');
        await new Promise(r => setTimeout(r, 500));
        
        // 2. Start journey mode
        log('Step 2: Starting journey mode (0A)...', 'info');
        await commandChar.writeValue(new Uint8Array([0x0A]));
        journeyMode = true;
        log('Journey mode started', 'success');
        await new Promise(r => setTimeout(r, 300));
        
        // 3. Send initial zero
        log('Step 3: Sending initial zero command...', 'info');
        writeStreamingCommand(buildStreamingCommand(0, 0x0002, 0), true);
        await new Promise(r => setTimeout(r, 100));
        
        // 4. Stream intensity values
        log('Step 4: Streaming intensity values...', 'info');
        const streamRateMs = 67;
        const duration = 5000;
        let ts = 0;
        let count = 0;
        const targetHz = 10;
        let phase = 0;
        const phaseIncrement = (targetHz * 2 * Math.PI) / (1000 / streamRateMs);
        
        const interval = setInterval(() => {
          const intensity = Math.floor((Math.sin(phase) + 1) / 2 * 65535);
          phase += phaseIncrement;
          ts += streamRateMs;
          count++;
          
          try {
            writeStreamingCommand(buildStreamingCommand(intensity, 0x0002, ts), count % 15 === 0);
          } catch (e) {
            log(`Stream error: ${e.message}`, 'error');
            clearInterval(interval);
          }
        }, streamRateMs);
        
        setTimeout(() => {
          clearInterval(interval);
          writeStreamingCommand(buildStreamingCommand(0, 0x0002, ts));
          log(`=== TEST COMPLETE (sent ${count} streaming commands) ===`, 'success');
          log('Did the light brightness change?', 'info');
        }, duration);
        
      } catch (e) {
        log(`Test error: ${e.message}`, 'error');
        console.error(e);
      }
    };
    
    // Expose to window for debug panel
    window.testFullStreaming = window.testFullStreaming;
    window.test01ffThenStreaming = window.test01ffThenStreaming;

    renderPresets();
  </script>
</body>
</html>
